<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flat 3D US Map</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #000;
      overflow: hidden;
    }
    #wrap {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #000;
      overflow: hidden;
    }
    #debug {
      position: absolute;
      left: 12px;
      top: 12px;
      z-index: 10;
      color: #fff;
      font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: rgba(0,0,0,.55);
      padding: 10px 12px;
      border-radius: 8px;
      max-width: 90%;
    }
    canvas { display:block; }
  </style>

  <!-- Libraries (hosted) -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/topojson-client@3/dist/topojson-client.min.js"></script>
  <script src="https://unpkg.com/d3-geo@3/dist/d3-geo.min.js"></script>
</head>
<body>
  <div id="wrap">
    <div id="debug">Loading…</div>
  </div>

  <script>
  (async function () {
    const wrap = document.getElementById('wrap');
    const debug = document.getElementById('debug');
    const setDbg = (m) => debug && (debug.textContent = m);

    if (!wrap) return;
    if (!window.THREE) { setDbg('Error: three.js did not load.'); return; }
    if (!window.topojson) { setDbg('Error: topojson-client did not load.'); return; }
    if (!window.d3) { setDbg('Error: d3-geo did not load.'); return; }

    // ===== YOUR STYLE =====
    const STATE_FILL = '#4cad49';
    const BORDER_COLOR = '#000000';
    const BG_COLOR = 0x000000;

    // Exclude Alaska (02), Hawaii (15), Rhode Island (44)
    const EXCLUDED = new Set(['02','15','44']);

    // Subtle 3D depth (keep small to stay "flat")
    const EXTRUDE_DEPTH = 2; // try 1 for even flatter

    // Very slight mouse parallax
    const PARALLAX = 10;     // smaller = less movement
    const LERP = 0.07;

    // ===== THREE SETUP =====
    setDbg('Initializing renderer…');

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setClearColor(BG_COLOR, 1);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.domElement.style.position = 'absolute';
    renderer.domElement.style.inset = '0';
    renderer.domElement.style.display = 'block';
    wrap.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    // Orthographic camera = "map on a page" (no globe)
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 5000);
    camera.position.set(0, 0, 800);
    camera.lookAt(0, 0, 0);

    // Lighting for the 3D edge
    scene.add(new THREE.AmbientLight(0xffffff, 0.85));
    const dir = new THREE.DirectionalLight(0xffffff, 0.65);
    dir.position.set(400, 600, 900);
    scene.add(dir);

    const mapGroup = new THREE.Group();
    scene.add(mapGroup);

    const fillMat = new THREE.MeshPhongMaterial({ color: new THREE.Color(STATE_FILL) });
    const edgeMat = new THREE.LineBasicMaterial({ color: new THREE.Color(BORDER_COLOR) });

    function resize() {
      const w = wrap.clientWidth || window.innerWidth;
      const h = wrap.clientHeight || window.innerHeight;

      renderer.setSize(w, h, false);

      camera.left = -w / 2;
      camera.right = w / 2;
      camera.top = h / 2;
      camera.bottom = -h / 2;
      camera.updateProjectionMatrix();

      return { w, h };
    }
    window.addEventListener('resize', () => resize());
    const { w, h } = resize();

    function fips2(id) { return String(id).padStart(2, '0'); }

    function clearGroup(g) {
      while (g.children.length) {
        const obj = g.children.pop();
        if (obj.geometry) obj.geometry.dispose?.();
      }
    }

    function walkRing(ring, proj, w, h) {
      const pts = [];
      for (const ll of ring) {
        const p = proj(ll); // [x,y]
        if (!p) continue;
        pts.push([p[0] - w/2, -(p[1] - h/2)]);
      }
      return pts;
    }

    function buildMeshes(featureCollection, proj, w, h) {
      clearGroup(mapGroup);

      featureCollection.features.forEach(feature => {
        const geom = feature.geometry;
        if (!geom) return;

        const polys = (geom.type === 'Polygon') ? [geom.coordinates]
                   : (geom.type === 'MultiPolygon') ? geom.coordinates
                   : [];

        polys.forEach(poly => {
          const outer = poly[0];
          if (!outer || outer.length < 3) return;

          const outerPts = walkRing(outer, proj, w, h);
          if (outerPts.length < 3) return;

          const shape = new THREE.Shape();
          outerPts.forEach((pt, i) => i === 0 ? shape.moveTo(pt[0], pt[1]) : shape.lineTo(pt[0], pt[1]));

          // Holes (lakes etc.)
          for (let hi = 1; hi < poly.length; hi++) {
            const holePts = walkRing(poly[hi], proj, w, h);
            if (holePts.length < 3) continue;
            const hole = new THREE.Path();
            holePts.forEach((pt, i) => i === 0 ? hole.moveTo(pt[0], pt[1]) : hole.lineTo(pt[0], pt[1]));
            shape.holes.push(hole);
          }

          const geo = new THREE.ExtrudeGeometry(shape, { depth: EXTRUDE_DEPTH, bevelEnabled: false });
          geo.translate(0, 0, -EXTRUDE_DEPTH / 2);

          mapGroup.add(new THREE.Mesh(geo, fillMat));
          mapGroup.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo, 25), edgeMat));
        });
      });
    }

    setDbg('Loading US states…');
    let topo;
    try {
      const res = await fetch('https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json');
      topo = await res.json();
    } catch (e) {
      setDbg('Error: Failed to fetch states data (network/CDN blocked).');
      return;
    }

    const allStates = topojson.feature(topo, topo.objects.states).features;
    const filtered = allStates.filter(f => !EXCLUDED.has(fips2(f.id)));
    const fc = { type: 'FeatureCollection', features: filtered };

    // Fit the projection to the viewport
    const projection = d3.geoAlbers().rotate([96, 0]).center([0, 37.5]);
    projection.fitExtent([[20, 20], [w - 20, h - 20]], fc);

    buildMeshes(fc, projection, w, h);

    // Tiny tilt gives "3D" feel while staying flat
    mapGroup.rotation.x = -0.12;

    setDbg('Loaded.');
    setTimeout(() => debug?.remove(), 1200);

    // Parallax
    let tx = 0, ty = 0, cx = 0, cy = 0;
    wrap.addEventListener('mousemove', (e) => {
      const r = wrap.getBoundingClientRect();
      const nx = ((e.clientX - r.left) / r.width) * 2 - 1;
      const ny = ((e.clientY - r.top) / r.height) * 2 - 1;
      tx = nx * PARALLAX;
      ty = -ny * PARALLAX;
    });

    function animate() {
      requestAnimationFrame(animate);
      cx += (tx - cx) * LERP;
      cy += (ty - cy) * LERP;
      camera.position.x = cx;
      camera.position.y = cy;
      camera.lookAt(0, 0, 0);
      renderer.render(scene, camera);
    }
    animate();
  })();
  </script>
</body>
</html>
